<command>
<name>publish ossi polval as projection with evaluated expressions</name>
<description>for passed in polcod, polvar see all polval and publish them out such that all polvals are on single row
and their values are based on concatenated expresison stored in rtstr1</description>
<type>Local Syntax</type>


<argument datatype="string" name="polcod"></argument>
<argument datatype="string" name="polvar"></argument>
<argument datatype="string" name="polval">Wild carded</argument>
<argument datatype="string" name="wh_id"></argument>


<local-syntax>
<![CDATA[


publish data
where wh_id = nvl(@wh_id, @@WH_ID)
and polval = nvl(@polval,'%')
and evaluate_as_literal = nvl(@evaluate_as_literal, 0)
|
{
    execute ossi moca and cache
    where uc_cache_key = 'UC_AS_PROJ_' || @wh_id || '_' || @polcod || '_' || @polvar
    and uc_cache_grp = 'OSSI__POLVAL'
    and uc_inline = 1
    and uc_moca_cmd = "
    [
    select polval, max(rtnum2) uc_literal
    from poldat_view
    where polcod = @polcod
    and polvar = @polvar
    and wh_id = @wh_id
    and polval like @polval
    and rtnum1 = 1
    group by polval
    order by 1
    ]
    catch (-1403,510)
    |
    if ( @? = 0 )
    {
        publish data
        where uc_eval_expr = ossi__polval_cat ( @polcod, @polvar, @polval, '', 'rtstr1', 'rtnum1=1', ' ', @wh_id )
        |
        filter data
        where moca_filter_level = 1
        and polcod = @polcod
        and polvar = @polvar
        and polval = @polval
        and publish_col = lower(ossi__replace(ossi__replace ( ossi__replace ( ossi__replace(@polval, ' ', '_' ), '-', '_' ), '/','_' ), '|', '_' ))
        and uc_eval_as_literal = iif ( @polval='ADDITIONAL-MOCA-FILTER' or @uc_literal > 0, 1, 0 )
    }"
    catch (-1403,510)
    >> res_pol
    |
    if ( @? = 0 and rowcount(@res_pol) > 0 )
    {
        [[
        StringBuffer v_publish_data_cmd = new StringBuffer();
        boolean first = true;
        //
        v_publish_data_cmd.append ( "publish data where " );
        //
        while ( res_pol.next() )
        {
            v_publish_column = res_pol.getString ( 'publish_col' );
            v_eval_expr      = res_pol.getString ( 'uc_eval_expr' );
            v_eval_as_literal= res_pol.getInt    ( 'uc_eval_as_literal' );
            //
            if ( !first )
               v_publish_data_cmd.append ( " and " );
            //
            if ( v_eval_as_literal == 1 )
                v_publish_data_cmd.append ( v_publish_column + " = '" + v_eval_expr.toString().replaceAll ( "'", "''") + "'" );
            else
                v_publish_data_cmd.append ( v_publish_column + " = " + v_eval_expr );
            first = false;
        }
        [uc_publish_data_cmd:v_publish_data_cmd.toString()]
        ]]
        |
        execute server command
        where cmd = @uc_publish_data_cmd
        and inline = 1
    }
}


]]>
</local-syntax>

<documentation>
<remarks>
We sometimes have multiple polvals defined under a polcod/polvar and our intention is to work with all of them.
One example is that we have setup for FTP and under a polcod/polvar we have several polval for DIRECTORY, FILENAME, etc.
Furthermore it is possible that we have expressions stored.  So this command can be used to publish them out as a single
row with actual values.
</remarks>

<exception value="eOK">Normal successful completion</exception>

<retrows>1</retrows>

<retcol name="polval value" type="COMTYP_CHAR"></retcol>
<retcol name="either rtstr1 as-is or evaluated" type="COMTYP_CHAR"></retcol>


<policy 
   polcod="ANY" 
   polvar="ANY" 
   polval="This is the value that is published.  We change space or - to _.  Special ADDITIONAL-MOCA-FILTER means that it is not an expression" 
   rtstr1="multiple rows conctenated together to form a single command.  Sorted by srtseq">
   rtnum1="1 to enable a row"
   rtnum2="1 to force that this is not an expression">
</policy>


</documentation>


</command>
